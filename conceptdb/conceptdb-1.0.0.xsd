<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           version="1.0.0"
           xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
           targetNamespace="http://www.julielab.de/conceptdb"
           xmlns="http://www.julielab.de/conceptdb"
           elementFormDefault="qualified"
           vc:minVersion="1.1">

    <xs:element name="version" type="xs:string"/>
    <xs:element name="uri" type="xs:string"/>
    <xs:element name="user" type="xs:string"/>
    <xs:element name="password" type="xs:string"/>
    <xs:element name="pluginname" type="xs:string"/>
    <xs:element name="pluginendpoint" type="xs:string"/>

    <xs:element name="versioning">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="version"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- Concept, facet and mappings import -->
    <xs:element name="concepts">
        <xs:annotation>
            <xs:documentation xml:lang="en">
                This is an extension point for concept creation providers. Those define their own XML Schema. For each
                provider, its configuration schema must be included in the configuration XML document. The provider root
                element - most commonly <em>creator</em> - then needs to have set the namespace to the respective XML
                Schema, e.g. &lt;creator xmlns="http://www.mydomain.de/myschema"&lt;.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:any/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="facet">
        <xs:annotation>
            <xs:documentation xml:lang="en">
                This is an extension point for facet creation providers. Those define their own XML Schema. For each
                provider, its configuration schema must be included in the configuration XML document. The provider root
                element - most commonly <em>creator</em> - then needs to have set the namespace to the respective XML
                Schema, e.g. &lt;creator xmlns="http://www.mydomain.de/myschema"&lt;.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:any/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="mappings">
        <xs:annotation>
            <xs:documentation xml:lang="en">
                This is an extension point for mapping creation providers. Those define their own XML Schema. For each
                provider, its configuration schema must be included in the configuration XML document. The provider root
                element - most commonly <em>creator</em> - then needs to have set the namespace to the respective XML
                Schema, e.g. &lt;creator xmlns="http://www.mydomain.de/myschema"&lt;. A commonly used mapping provider
                is contained in the <em>julielab-concept-creation-bioportal</em> project.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:any/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="import">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="serverplugininserter"/>
                <xs:element ref="concepts" minOccurs="0"/>
                <xs:element ref="facet" minOccurs="0"/>
                <xs:element ref="mappings" minOccurs="0"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="imports">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="import" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="serverplugininserter">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="pluginname"/>
                <xs:element ref="pluginendpoint"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <!-- End imports -->


    <!-- In-database operations -->

    <xs:element name="serverpluginoperator">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="pluginname"/>
                <xs:element ref="pluginendpoint"/>
                <xs:element name="configuration" type="methodcallconfigtype"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>


    <xs:element name="filedboperator">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="configuration" type="methodcallconfigtype"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="operation">
        <xs:complexType>
            <xs:choice>
                <xs:element ref="serverpluginoperator"/>
                <xs:element ref="filedboperator"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="operations">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="operation" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- End database operations -->


    <!-- Data export -->
    <!-- Decoding possibilities -->
    <xs:element name="json2bytearray" type="xs:boolean">
        <xs:annotation>
            <xs:documentation xml:lang="en">
                Since it is not possible to transfer a byte stream directly from a Neo4j server plugin, one possibility
                is to encode the byte stream as a JSON array. Each byte is then a number in the resulting JSON array.
                Setting this element to true will lead to interpret the data sent by the server plugin as JSON-encoded
                byte array. Refer to the plugin documentation to learn which encoding methodology is employed. This
                method is very inefficient and shouldn't be used by server plugins. Use the base64 encoding instead.
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="base64" type="xs:boolean">
        <xs:annotation>
            <xs:documentation xml:lang="en">
                Since it is not possible to transfer a byte stream directly from a Neo4j server plugin, one possibility
                is to encode the byte stream in a base64 string and send this. Setting this element to true will result
                have the data receiving code attempting to decode a base64 string into a byte stream. Refer to the
                plugin documentation to learn which encoding methodology is employed.
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="gzip" type="xs:boolean">
        <xs:annotation>
            <xs:documentation xml:lang="en">
                If the data sent by the server plugin is in GZIP format, set this element to true for uncompressing the
                data before writing it into the output file.
            </xs:documentation>
        </xs:annotation>
    </xs:element>

    <xs:element name="decoding">
        <xs:annotation>
            <xs:documentation xml:lang="en">
                When exporting data from the database, complex data is typically encoded into a string. This element
                allows to specify how to retrieve the original data. What to use depends on the server plugin or file
                database method that is employed.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:choice>
                    <xs:element ref="json2bytearray"/>
                    <xs:element ref="base64"/>
                </xs:choice>
                <xs:sequence>
                    <xs:element ref="gzip"/>
                </xs:sequence>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="outputfile" type="xs:string"/>






    <!-- The type for cypher queries -->
    <xs:complexType name="cypherquerytype">
        <xs:sequence>
            <xs:element name="cypherquery" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="exportcypherquerytype">
        <xs:complexContent>
            <xs:extension base="cypherquerytype">
                <xs:sequence>
                    <xs:element ref="outputfile"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!-- This extends the methodcallconfigtype with decoding of retrieved data and a file to write the output to -->
    <xs:complexType name="exportconfigurationtype">
        <xs:complexContent>
            <xs:extension base="methodcallconfigtype">
                <xs:sequence>
                    <xs:element ref="decoding"/>
                    <xs:element name="outputfile" type="xs:string"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="exportertype">
        <xs:sequence>
            <xs:element name="configuration" type="exportconfigurationtype"/>
        </xs:sequence>
        <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="serverpluginexportertype">
        <xs:complexContent>
            <xs:extension base="exportertype">
                <xs:sequence>
                    <xs:element ref="pluginname"/>
                    <xs:element ref="pluginendpoint"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="boltexportertype">
        <xs:sequence>
            <xs:element name="configuration" type="exportcypherquerytype"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="exports">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="export" maxOccurs="unbounded">
                    <xs:complexType>
                        <xs:attribute name="type" use="required">
                            <xs:simpleType>
                                <xs:restriction base="xs:string">
                                    <xs:enumeration value="serverplugin"/>
                                    <xs:enumeration value="filedb"/>
                                    <xs:enumeration value="bolt"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                    </xs:complexType>
                    <xs:alternative test="@type = serverplugin" type="serverpluginexportertype"/>
                    <xs:alternative test="@type = filedb" type="exportertype"/>
                    <xs:alternative test="@type = bolt" type="boltexportertype"/>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- End data export -->

    <xs:element name="connection">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="uri"/>
                <xs:element ref="user"/>
                <xs:element ref="password"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="conceptdatabase">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="versioning"/>
                <xs:element ref="connection"/>
                <xs:element ref="imports" minOccurs="0"/>
                <xs:element ref="exports" minOccurs="0"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>